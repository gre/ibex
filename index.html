<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS13K</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <canvas id="C"></canvas>
  <script id="vertexLogic" type="x-shader/x-vertex">
    attribute vec2 position;
    void main() {
      gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);
    }
  </script>
  <script id="fragmentLogic" type="x-shader/x-fragment">
    #define AC(a) if(r==a)c=colors[a];

    // Elements
    #define N 0
    #define E 1
    #define F 2
    #define W 3
    #define V 4
    #define S 5
    #define A 6
    // wildcard
    #define _ 7

    /**
      * Game Rule Interactions.
      *
      * Each interaction use various probability. Some are very rare, some frequent.
      /!\ here air means wind /!\ it is different of empty, the empty space is called "Nothing" aka N)
      *
      * Primary elements: Water, Fire, Earth, Air
      * =======
      * Water + Nothing => fall / slide
      * Fire + Nothing => grow
 TODO     * Air + Nothing => move (directional wind)
 TODO     * Water + Fire => sometimes creates Air (Steam/Wind)
 TODO     * Water + Air => Water is deviated (wind)
 TODO     * Fire + Air => Fire decrease IF not surrounded by air OTHERWISE is increase (need oxygen)
      * Earth + Water => rarely creates Water Source (water infiltration)
      * Earth + Fire => rarely creates Volcano (fire melt ground into lava)
 TODO     * Earth + Air => sometimes Destroy (erosion), rarely creates Volcano (spark)
      *
      * Secondary elements: Source, Volcano
      * =========
      * Source + Nothing => creates Water (on bottom).
      * Volcano + Nothing => creates Fire (on top)
 TODO     * Volcano + Source => IF source on top of volcano: sometimes creates Ground. OTHERWISE: sometimes creates volcano.
      * Volcano + Water => rarely creates Source.
      * Earth + Volcano => rarely Volcano expand / grow up in the Earth.
      * Earth + Source => rarely Source expand / infiltrate in the Earth.
      * Source + Fire => Source die.
      *
      * Cases where nothing happens:
      * Earth + Nothing
      * Volcano + Fire
      * Volcano + Air
      * Source + Air
      * Source + Water

      */
  
    precision highp float;
    uniform vec2 size;
    uniform float time;
    uniform sampler2D state;

    uniform vec3 colors[_];

    vec4 getColor(ivec2 position) {
      vec2 uv = (gl_FragCoord.xy + vec2(position)*vec2(1.0, -1.0)/* quick fix for the currently reversed Y ...*/) / size;
      if (uv.x < 0.0 || uv.x >= 1.0 || uv.y < 0.0 || uv.y >= 1.0)
        return vec4(colors[0], 0.0);
      return texture2D(state, uv);
    }
    int get (ivec2 pos) {
      vec3 cmp = getColor(pos).rgb;
      for (int i=0; i<_; ++i) {
        vec3 ref = colors[i];
        if (distance(cmp, ref) < 0.01)
          return i;
      }
      return 0;
    }
    int get (int x, int y) {
      return get(ivec2(x, y));
    }


    // Match with weights
    float match (mat3 pattern, mat3 weights) {
      float w = 0.0;
      for (int x=-1; x<=1; ++x) {
        for (int y=-1; y<=1; ++y) {
          int v = int(pattern[y+1][x+1]);
          if (v == _ || v == get(x, y)) {
            w += weights[y+1][x+1];
          }
        }
      }
      return w;
    }

    // Match a pattern and return the nb of matches (ignoring the wildcards)
    int match (mat3 pattern) {
      mat3 w = mat3(0.0);
      for (int x=0; x<=2; ++x) {
        for (int y=0; y<=2; ++y) {
          if (int(pattern[y][x]) != _)
            w[y][x] = 1.0;
        }
      }
      return int(match(pattern, w));
    }

    bool matchAll (mat3 pattern) {
      mat3 w = mat3(1.0,1.0,1.0, 1.0,1.0,1.0, 1.0,1.0,1.0);
      return match(pattern, w) == 9.0;
    }

    bool matchAny (mat3 pattern) {
      return match(pattern) > 1;
    }
    bool matchOne (mat3 pattern) {
      return matchAny(pattern);
    }

    bool between (float f, float a, float b) {
      return a <= f && f <= b;
    }

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    void main () {
      float o = rand(gl_FragCoord.xy + 0.01*time * 0.1);
      float oo = rand(gl_FragCoord.xy + 0.03*time * 9.1 + 13.91);
      
      int prev = get(0, 0);

      int r = N;

      //////// FIRE RULES ///////

      if (
       // Fire grow / Fire + Water
       match(mat3(
         W, W, W, // If water drop...
         W, W, W, // ...or water nearby.
         F, F, F  // Fire will move up and expand a bit.
       ), mat3(
         -0.05, -0.3, -0.05, // Negative weights because water kill fire.
         -0.5, -0.6, -0.5,
         0.35, 0.9, 0.35 // Weights for the Fire
       )) >= 0.9 - 0.6 * oo // The sum of matched weights must be enough important, also with some randomness
      ) {
        r = F;
      }

      ////// WATER RULES ///////

      if (
      // Water drop / Water + Fire
       between(match(mat3(
         W, W, W,
         W, F, W,
         _, F, _
       ), mat3(
         0.3, 0.9, 0.3,
         0.1, -0.3, 0.1,
         0.0, -0.3, 0.0
       )), 0.9 - 0.6 * o, 1.4 + 0.3 * oo)
       ||
       // Water Slide rules
       (
        prev == N && (
          oo < 0.97 && (
          matchAll(mat3(
            W, _, _,
            _, _, _,
            E, _, _))
          ||
          matchAll(mat3(
            _, _, W,
            _, _, _,
            _, _, E))
          )
          ||
          oo < 0.92 && (
          matchAll(mat3(
            _, _, _,
            W, _, _,
            E, _, _))
          ||
          matchAll(mat3(
            _, _, _,
            _, _, W,
            _, _, E))
          )))) {
        r = W;
      }

      ////// EARTH RULES ////

      if (prev == E) {
        r = E;

        // Earth -> Source
        if (
        o<0.01 &&
        match(mat3(
          W, W, W,
          W, _, W,
          W, W, W
        ), mat3(
         1.0, 1.2, 1.0,
         0.5, 0.0, 0.5,
         0.3, 0.2, 0.3
        ))>3.0 - 2.5*oo
        ||

        o < 0.03 &&
        1<=match(mat3(
          _, S, _,
          S, _, S,
          _, _, _
        ))) {
          r = S;
        }

        // Earth -> Volcano
        if (
        oo < 0.006 && 
        match(mat3(
          F, F, F,
          F, _, F,
          F, F, F
        ), mat3(
         0.3, 0.2, 0.3,
         0.5, 0.0, 0.5,
         1.0, 1.2, 1.0
        ))>3.0 - 2.1*o

        ||

        oo < 0.01 &&
        2<=match(mat3(
          _, _, _,
          V, _, V,
          V, V, V
        ))) {
          r = V;
        }
      }

      ////// VOLCANO RULES /////
      
      // Volcano creates fire
      if ((prev==N || prev==F) && matchAll(mat3(
          _, _, _,
          _, _, _,
          _, V, _))) {
        r = F;
      }

      if (prev == V) {
        r = V;

        // if Water: Volcano -> Earth
        if (matchAny(mat3(
          W, W, W,
          W, _, W,
          _, _, _
        ))) {
          r = E;
        }

        // cool down: Volcano -> Earth
        if (oo<0.005 && !matchAny(mat3(
          _, _, _,
          _, _, _,
          F, F, F
        )) && !matchAny(mat3(
          _, _, _,
          _, _, _,
          V, V, V
        ))) {
          r = E;
        }

        // Volcano <-> Source : A volcano can disappear near source
        if (matchAny(mat3(
          S, S, S,
          S, _, S,
          S, S, S
        ))) {
          if (o < 0.3) {
            r = V;
          }
          else if (o < 0.5) {
            r = S;
          }
          else {
            r = E;
          }
        }
        
      }

      ////// SOURCE RULES /////

      if ((prev==N || prev==W) && match(mat3(
          S, S, S,
          S, _, S,
          _, _, _), mat3(
          0.9, 1.0, 0.9,
          0.7, 0.0, 0.7,
          0.0, 0.0, 0.0
        )) >= 1.0 - 0.3*o) {
        r = W;
      }

      if (prev == S) {
        r = S;

        // Dry: Source -> Earth
        if (oo<0.05 && !matchAny(mat3(
          W, W, W,
          _, _, _,
          _, _, _
        )) && !matchAny(mat3(
          S, S, S,
          _, _, _,
          _, _, _
        ))) {
          r = E;
        }

        // if Fire: Source -> Earth
        if (matchAny(mat3(
          _, _, _,
          F, _, F,
          F, F, F
        ))) {
          r = E;
        }

        // Volcano <-> Source : A source can disappear near volcano
        if (matchAny(mat3(
          V, V, V,
          V, _, V,
          V, V, V
        ))) {
          if (o < 0.2) {
            r = V;
          }
          else if (o < 0.6) {
            r = S;
          }
          else {
            r = E;
          }
        }

      }

      ///// Return the color result /////

      vec3 c;AC(0)AC(1)AC(2)AC(3)AC(4)AC(5)AC(6)gl_FragColor=vec4(c,1.0); //: gl_FragColor=vec4(colors[r], 1.0);
    }
  </script>
  
  <script id="vertexRender" type="x-shader/x-vertex">
    attribute vec2 position; void main() { gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);}
  </script>
  <script id="fragmentRender" type="x-shader/x-fragment">
    precision highp float;

    #define OUTCOLOR vec4(0.0)

    uniform float time;
    uniform sampler2D state;

    uniform vec2 worldSize;
    uniform vec2 resolution;

    uniform float zoom;
    uniform vec2 camera;

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }
    
    void main () {
      /*
      vec2 disp = 1.0*vec2(
        cos(2.3*time+0.03*gl_FragCoord.x+0.5),
        sin(2.0*time+0.04*gl_FragCoord.y+0.1)
        );
        */
      float disp = 0.0;

      // Compute where the camera/zoom is in the state texture
      vec2 statePos = (gl_FragCoord.xy + disp + camera) / zoom;
      vec2 stateBound = worldSize;
      vec2 uv = (floor(statePos) + 0.5) / stateBound;
      vec4 stateColor = uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0 ? OUTCOLOR : texture2D(state, uv);


      vec2 pixelPos = fract(statePos);

      vec3 noiseColor = vec3(0.02) * vec3(
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/31.0),
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/80.1),
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/13.2)
      );

      vec3 pixelColor = -vec3(0.03) * (pixelPos.x - pixelPos.y);

      gl_FragColor = vec4(noiseColor + pixelColor, 1.0) + stateColor;
    }
  </script>
  <script src="index.js"></script>
</body>
</html>
