<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IBEX</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  Loading...
  
  <script id="vertexLogic" type="x-shader/x-vertex">
    attribute vec2 position;
    void main() {
      gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);
    }
  </script>
  <script id="fragmentLogic" type="x-shader/x-fragment">
    #define AC(a) if(r==a)c=colors[a];
    #define RtoC AC(0)AC(1)AC(2)AC(3)AC(4)AC(5)AC(6)AC(7)AC(8)
    #define RAND (s=vec2(rand(s), rand(s+9.))).x

    // Elements
    #define A 0
    #define E 1
    #define F 2
    #define W 3
    #define V 4
    #define S 5
    #define Al 6
    #define Ar 7
    #define G 8
    // wildcard
    #define _ 9

    /**
      * Game Rule Interactions.
      *
      * Each interaction use various probability. Some are very rare, some frequent.
      /!\ here air means wind /!\ it is different of empty, the empty space is called "Nothing" aka N)
      *
      * Primary elements: Water, Fire, Earth, Air
      * =======
      * Water + Nothing => fall / slide
      * Fire + Nothing => grow
 TODO     * Air + Nothing => move (directional wind)
 TODO     * Water + Fire => sometimes creates Air (Steam/Wind)
 TODO     * Water + Air => Water is deviated (wind)
 TODO     * Fire + Air => Fire decrease IF not surrounded by air OTHERWISE is increase (need oxygen)
      * Earth + Water => rarely creates Water Source (water infiltration)
      * Earth + Fire => rarely creates Volcano (fire melt ground into lava)
 TODO     * Earth + Air => sometimes Destroy (erosion), rarely creates Fire (spark)
      *
      * Secondary elements: Source, Volcano
      * =========
      * Source + Nothing => creates Water (on bottom).
      * Volcano + Nothing => creates Fire (on top)
 TODO     * Volcano + Source => IF source on top of volcano: sometimes creates Ground. OTHERWISE: sometimes creates volcano.
      * Volcano + Water => rarely creates Source.
      * Earth + Volcano => rarely Volcano expand / grow up in the Earth.
      * Earth + Source => rarely Source expand / infiltrate in the Earth.
      * Source + Fire => Source die.
      *
      * Cases where nothing happens:
      * Earth + Nothing
      * Volcano + Fire
      * Volcano + Air
      * Source + Air
      * Source + Water

      */
  
    precision highp float;
    uniform vec2 size;
    uniform float seed;
    uniform float tick;
    uniform sampler2D state;

    uniform bool draw;
    uniform ivec2 drawPosition;
    uniform float drawRadius;
    uniform int drawObject;

    uniform vec3 colors[_];

    vec4 getColor(ivec2 position) {
      vec2 uv = (gl_FragCoord.xy + vec2(position)) / size;
      if (uv.x < 0.0 || uv.x >= 1.0 || uv.y < 0.0 || uv.y >= 1.0)
        return vec4(colors[0], 0.0);
      return texture2D(state, uv);
    }
    int get (ivec2 pos) {
      vec3 cmp = getColor(pos).rgb;
      for (int i=0; i<_; ++i) {
        vec3 ref = colors[i];
        if (distance(cmp, ref) < 0.01)
          return i;
      }
      return 0;
    }
    int get (int x, int y) {
      return get(ivec2(x, y));
    }


    // Match with weights
    float match (mat3 pattern, mat3 weights, ivec2 off) {
      float w = 0.0;
      for (int x=-1; x<=1; ++x) {
        for (int y=-1; y<=1; ++y) {
          int v = int(pattern[-y+1][x+1]);
          if (v == _ || v == get(x+off.x, y+off.y)) {
            w += weights[-y+1][x+1];
          }
        }
      }
      return w;
    }

    float match (mat3 pattern, mat3 weights) {
      return match(pattern, weights, ivec2(0));
    }

    // Match a pattern and return the nb of matches (ignoring the wildcards)
    int match (mat3 pattern) {
      mat3 w = mat3(0.0);
      for (int x=0; x<=2; ++x) {
        for (int y=0; y<=2; ++y) {
          if (int(pattern[y][x]) != _)
            w[y][x] = 1.0;
        }
      }
      return int(match(pattern, w));
    }

    bool matchAll (mat3 pattern, ivec2 off) {
      mat3 w = mat3(1.0,1.0,1.0, 1.0,1.0,1.0, 1.0,1.0,1.0);
      return match(pattern, w, off) == 9.0;
    }

    bool matchAll (mat3 pattern) {
      return matchAll(pattern, ivec2(0));
    }

    bool matchAny (mat3 pattern) {
      return match(pattern) > 1;
    }
    bool matchOne (mat3 pattern) { // FIXME replace with "matchLeft, matchRight, matchTop, matchBottom" ?
      return matchAny(pattern);
    }

    bool matchAnyAdjacent (int e) {
      return matchAny(mat3(
        e, e, e,
        e, _, e,
        e, e, e));
    }

    bool between (float f, float a, float b) {
      return a <= f && f <= b;
    }

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    float grassDistrib (vec2 p) {
      return mix(rand(vec2(p.x)), 0.5*(1.0+(cos(sin(p.y*0.01 + p.x * 0.05) + (1.0 + 0.3*sin(p.x*0.01)) * p.y * 0.08))), 0.5);
    }

    void main () {
      float x = gl_FragCoord.x;
      float y = gl_FragCoord.y;
      
      int prev = get(0, 0);
      int down = get(0, -1);

      vec2 s = gl_FragCoord.xy + 0.001 * tick;

      bool prevIsSolid = prev==E||prev==G||prev==V||prev==S;

      int r = A;

      //////// FIRE RULES ///////

      if (
       // Fire grow / Fire + Water
       match(mat3(
         W, W, W, // If water drop...
         W, W, W, // ...or water nearby.
         F, F, F  // Fire will move up and expand a bit.
       ), mat3(
         -0.05, -0.3, -0.05, // Negative weights because water kill fire.
         -0.5, -0.6, -0.5,
         0.35, 0.9, 0.35 // Weights for the Fire
       )) >= 0.9 - 0.6 * RAND // The sum of matched weights must be enough important, also with some randomness
      ) {
        r = F;
      }

      // Fire propagation: When fire met grass, fire can stay to continue to consume it
      if (prev == F && RAND < 0.6 && matchAnyAdjacent(G)) {
        r = F;
      }

      ////// WATER RULES ///////

      if (
      // Water drop / Water + Fire
       between(match(mat3(
         W, W, W,
         W, F, W,
         _, F, _
       ), mat3(
         0.3, 0.9, 0.3,
         0.1, -0.3, 0.1,
         0.0, -0.3, 0.0
       )), 0.9 - 0.6 * RAND, 1.4 + 0.3 * RAND)
       ||
       // Water flow rules
       (
        !prevIsSolid && (
          RAND < 0.98 && (
          matchAll(mat3(
            W, _, _,
            _, _, _,
            E, _, _))
          ||
          matchAll(mat3(
            _, _, W,
            _, _, _,
            _, _, E))
          )
          ||
          RAND < 0.93 && (
          matchAll(mat3(
            _, _, _,
            W, _, _,
            E, _, _))
          ||
          matchAll(mat3(
            _, _, _,
            _, _, W,
            _, _, E))
          )))) {
        r = W;
      }

      // Occasional rain
      float rainRelativeTime = mod(tick, 300.0);
      if (!prevIsSolid &&
          y >= size[1]-1.0 &&
          rainRelativeTime < 100.0) {
        float rainLgth = 100.0 * rand(vec2(seed + tick - rainRelativeTime));
        float rainStart = rand(vec2(seed*0.7 + tick - rainRelativeTime)) * (size[0]-rainLgth);
        if (rainStart < x && x < rainStart+rainLgth)
          r = W;
      }

      ////// EARTH RULES ////

      if (prev == E) {

        if (!(get(-1, 0)==A && get(1, 0)==A)) // Hack to workaround with the bug in the terrain seamless
          r = E;

        // Earth -> Source
        if (
        RAND<0.01 &&
        match(mat3(
          W, W, W,
          W, _, W,
          W, W, W
        ), mat3(
         1.0, 1.2, 1.0,
         0.5, 0.0, 0.5,
         0.3, 0.2, 0.3
        ))>3.0 - 2.5*RAND
        ||

        RAND < 0.03 &&
        1<=match(mat3(
          _, S, _,
          S, _, S,
          _, _, _
        ))) {
          r = S;
        }

        // Earth -> Volcano
        if (
        RAND < 0.006 && 
        match(mat3(
          F, F, F,
          F, _, F,
          F, F, F
        ), mat3(
         0.3, 0.2, 0.3,
         0.5, 0.0, 0.5,
         1.0, 1.2, 1.0
        ))>3.0 - 2.1*RAND

        ||

        RAND < 0.01 &&
        2<=match(mat3(
          _, _, _,
          V, _, V,
          V, V, V
        ))) {
          r = V;
        }
      }

      ////// Grass RULES ////
      int grassMaxHeight = int(20.0 * pow(grassDistrib(gl_FragCoord.xy), 1.4));
      if (grassMaxHeight > 0) {
        if (prev == G) {
          r = G;
          if (RAND < 0.95 && (
            matchAny(mat3(
              F, F, F,
              F, _, F,
              F, F, F
            ))
            ||
            matchAny(mat3(
              V, V, V,
              V, _, V,
              V, V, V
            ))
          )) {
            r = F;
          }
        }
        else if (!prevIsSolid && (matchAnyAdjacent(E) || matchAnyAdjacent(G) || matchAnyAdjacent(S))) {
          if (RAND < 0.02 &&
            get(0, -grassMaxHeight) != G && (
            down==G && RAND < 0.07 || // The grass sometimes grow
            down==E && RAND < 0.02 || // The grass rarely spawn by itself
            matchAny(mat3(
              W, W, W,
              W, _, W,
              W, W, W
            ))
            ||
            matchAny(mat3(
              S, S, S,
              S, _, S,
              S, S, S
            ))
          )) {
            r = G;
          }
        }
      }


      ////// VOLCANO RULES /////
      
      // Volcano creates fire
      if ((!prevIsSolid || prev==F) && matchAll(mat3(
          _, _, _,
          _, _, _,
          _, V, _))) {
        r = F;
      }

      if (prev == V) {
        r = V;

        // if Water: Volcano -> Earth
        if (matchAny(mat3(
          W, W, W,
          W, _, W,
          _, _, _
        ))) {
          r = RAND < 0.8 ? S : E;
        }

        // cool down: Volcano -> Earth
        if (RAND<0.005 && !matchAny(mat3(
          _, _, _,
          _, _, _,
          F, F, F
        )) && !matchAny(mat3(
          _, _, _,
          _, _, _,
          V, V, V
        ))) {
          r = E;
        }

        // Volcano <-> Source : A volcano can disappear near source
        if (matchAny(mat3(
          S, S, S,
          S, _, S,
          S, S, S
        ))) {
          if (RAND < 0.3) {
            r = V;
          }
          else if (RAND < 0.6) {
            r = S;
          }
          else {
            r = E;
          }
        }
        
      }

      // Occasional volcano
      float volcRelativeTime = mod(tick, 25.0);
      if (prevIsSolid &&
          y <= 1.0 &&
          RAND < 0.3 &&
          volcRelativeTime <= 1.0) {
        float volcLgth = 10.0 * rand(vec2(seed*0.07 + tick - volcRelativeTime));
        float volcStart = rand(vec2(seed*0.01 + tick - volcRelativeTime)) * (size[0]-volcLgth);
        if (volcStart < x && x < volcStart+volcLgth)
          r = V;
      }

      ////// SOURCE RULES /////

      if ((!prevIsSolid || prev==W) && match(mat3(
          S, S, S,
          S, _, S,
          _, _, _), mat3(
          0.9, 1.0, 0.9,
          0.7, 0.0, 0.7,
          0.0, 0.0, 0.0
        )) >= 1.0 - 0.3*RAND) {
        r = W;
      }

      if (prev == S) {
        r = S;

        // Dry: Source -> Earth
        if (RAND<0.06 && !matchAny(mat3(
          W, W, W,
          _, _, _,
          _, _, _
        )) && !matchAny(mat3(
          S, S, S,
          _, _, _,
          _, _, _
        ))) {
          r = E;
        }

        // if Fire: Source -> Earth
        if (matchAny(mat3(
          _, _, _,
          F, _, F,
          F, F, F
        ))) {
          r = E;
        }

        // Volcano <-> Source : A source can disappear near volcano
        if (matchAny(mat3(
          V, V, V,
          V, _, V,
          V, V, V
        ))) {
          if (RAND < 0.2) {
            r = V;
          }
          else if (RAND < 0.6) {
            r = S;
          }
          else {
            r = E;
          }
        }
      }

      ////// AIR RULES //////
      if (r == A) {
        if (RAND < 0.00001) r = Al;
        if (RAND < 0.00001) r = Ar;
      }

      if (!prevIsSolid && RAND < 0.6 && (
        matchAll(mat3(
          _, _, W,
          _, _, Al,
          _, _, _
        ))
        ||
        matchAll(mat3(
          W, _, _,
          Ar,_, _,
          _, _, _
        ))
      )) {
        r = W;
      }

      int wind = r==Al ? Al : r == Ar ? Ar : 0;
      float maxWind = 0.95;
      float f = match(mat3(
        Ar, _, Al,
        Ar, _, Al,
        Ar, _, Al
        ), mat3(
        -0.1+0.05*(RAND-0.5), 0.0, 0.1,
        -0.65, 0.0, 0.65,
        -0.2, 0.0, 0.2+0.05*(RAND-0.5)
      ));
      if (between(f, 0.4 * RAND, maxWind)) {
        wind = Al;
      }
      else if (between(f, -maxWind, -0.4 * RAND)) {
        wind = Ar;
      }

      if (wind != 0) {
        if (r == A) {
          r = wind;
        }
        else if(r == F) {
          if (RAND < 0.4) r = wind;
        }
        else if (r == W) {
          if (RAND < 0.1) r = wind;
        }
      }

      //// DRAW //////

      if (draw) {
        vec2 pos = floor(gl_FragCoord.xy);
        if (distance(pos, vec2(drawPosition)) <= drawRadius) {
          if (drawObject == W) {
            if (prevIsSolid) {
              r = S;
            }
            else if (!prevIsSolid && mod(pos.x + pos.y, 2.0)==0.0) {
              r = W;
            }
          }
          else if (drawObject == F) {
            if (prevIsSolid) {
              r = V;
            }
            else {
              r = F;
            }
          }
          else {
            r = drawObject;
          }
        }
      }
      ///// Return the color result /////

      // r = int(grassDistrib(gl_FragCoord.xy) * 3.0); // for TEST

      vec3 c;RtoC
      gl_FragColor=vec4(c,1.0); //: gl_FragColor=vec4(colors[r], 1.0);
    }
  </script>
  
  <script id="vertexRender" type="x-shader/x-vertex">
    attribute vec2 position; void main() { gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);}
  </script>
  <script id="fragmentRender" type="x-shader/x-fragment">
    #define AC(a) if(r==a)c=colors[a];
    #define RtoC AC(0)AC(1)AC(2)AC(3)AC(4)AC(5)AC(6)AC(7)AC(8)

    #define MAX_ANIMALS 20
    #define UI_SIZE 64.
    #define UI_LENGTH 4

    #define N 0
    #define E 1
    #define F 2
    #define W 3
    #define V 4
    #define S 5
    #define Al 6
    #define Ar 7
    #define G 8
    #define _ 9
  
    precision highp float;

    uniform vec3 colors[_];

    //uniform int uiElements[UI_LENGTH];

    uniform vec2 worldSize;
    uniform vec2 resolution;

    uniform float zoom;
    uniform vec2 camera;
    uniform vec2 mouse;
    uniform vec2 dragStart;
    uniform bool enableCursor;
    uniform bool started;
    uniform bool gameover;
    uniform float score;

    uniform float time;
    uniform sampler2D state;
    uniform float animals[8 * MAX_ANIMALS]; // array of [x, y, vx, vy, size, deathReason, deathTime, slope]
    uniform int animalsLength;
    uniform sampler2D tiles;

    uniform bool draggingElement;
    uniform float drawRadius;
    uniform int drawObject;

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }


  // source: http://glslsandbox.com/e#19207.5

  //3x5 digit sprites stored in "15 bit" numbers
  /*
  ███     111
    █     001
  ███  -> 111  -> 111001111100111 -> 29671
  █       100
  ███     111
  */

  float c_0 = 31599.0;
  float c_1 = 9362.0;
  float c_2 = 29671.0;
  float c_3 = 29391.0;
  float c_4 = 23497.0;
  float c_5 = 31183.0;
  float c_6 = 31215.0;
  float c_7 = 29257.0;
  float c_8 = 31727.0;
  float c_9 = 31695.0;

float extract_bit(float n, float b)
{
  n = floor(n);
  b = floor(b);
  b = floor(n/pow(2.,b));
  return float(mod(b,2.) == 1.);
}
float fpmod(vec2 p, float l)
{
  p *= l;
  return mod(p.x + 257. + mod(p.y + 17. + mod(-p.y + 5. + mod(p.x + 3. , l),l),l),l);
}

float sprite(float n, float w, float h, vec2 p)
{
  float bounds = float(all(lessThan(p,vec2(w,h))) && all(greaterThanEqual(p,vec2(0,0))));
  return extract_bit(n,(2.0 - p.x) + 3.0 * p.y) * bounds;
}

float bit_row(float bit, float scale, vec2 p)
{
  float r = 0.;
  float bounds = 0.;
  for(int i = 0; i < 8; i++)
  {
    bounds = float(all(lessThan(p, vec2(scale, scale))) && all(greaterThanEqual(p, vec2(0,0))));	
    r += extract_bit(bit, float(i)) * bounds;
    p.x -= scale;
  }
  return r;
}

float digit(float num, vec2 p)
{
  num = mod(floor(num),10.0);
  if(num == 0.0) return sprite(c_0, 3., 5., p);
  if(num == 1.0) return sprite(c_1, 3., 5., p);
  if(num == 2.0) return sprite(c_2, 3., 5., p);
  if(num == 3.0) return sprite(c_3, 3., 5., p);
  if(num == 4.0) return sprite(c_4, 3., 5., p);
  if(num == 5.0) return sprite(c_5, 3., 5., p);
  if(num == 6.0) return sprite(c_6, 3., 5., p);
  if(num == 7.0) return sprite(c_7, 3., 5., p);
  if(num == 8.0) return sprite(c_8, 3., 5., p);
  if(num == 9.0) return sprite(c_9, 3., 5., p);
  return 0.0;
}

float number (float n, vec2 p)
{
  float c = 0.;
  vec2 cpos = vec2(1,1);
  c += digit(n/100000.,floor(p-cpos));
  cpos.x += 4.;
  c += digit(n/10000.,floor(p-cpos));
  cpos.x += 4.;
  c += digit(n/1000.,floor(p-cpos));
  cpos.x += 4.;
  c += digit(n/100.,floor(p-cpos));
  cpos.x += 4.;
  c += digit(n/10.,floor(p-cpos));
  cpos.x += 4.;
  c += digit(n,floor(p-cpos));
  return c;
}


    vec4 animal (vec2 p, vec2 pos, vec2 v, float size, float d, float T, float s) {
      // Died displacement
      vec2 disp = d>0.0 ?
        (1.0 + v - mix(vec2(0.0), v, pow(smoothstep(0.0, 0.5, time-T), 0.3))) +
        vec2(rand(gl_FragCoord.xy+time*0.03)-0.5, rand(gl_FragCoord.xy+time*0.1)-0.5) *
        mix(1., 8., pow(smoothstep(1.0, 6.0, time-T), 0.6))
        : vec2(0.0);

      // if (distance(p, pos) < 1.0) return vec4(1.0, 0.0, 0.0, 1.0); // DEBUG

      // The tile to use
      float tile = abs(v.x) < 0.1 ? 0.0 : 1.0 + floor(mod(pos.x / size, 3.0));

      // pos: relative position & scaled to size
      pos = (disp + p - pos) / size;
      // Invert in X according to velocity
      if (v.x > 0.0) pos.x = -pos.x;
      // Slope deform the animal
      float slope = /*pos.y >= 5.0 ? 0.0 :*/ clamp(s, -3., 3.) * smoothstep(0.0, 4.0, pos.x);
      // Translate to the pivot
      pos += vec2(3.5, slope);
      // Scale to the tile width (to match the same pixel world dimension)
      pos /= 8.0;

      // When out of bound, return nothing
      if (pos.x <= 0.0 || pos.y <= 0.0 || pos.x >= 1.0 || pos.y >= 1.0) return vec4(0.0);

      // Compute the position from where to lookup in tiles
      vec2 uv =
        mix(
          vec2(0.0, (1.0+tile) / 4.0), // uv to
          vec2(1.0, tile / 4.0), // uv from
          pos // the position
        );
      vec4 clr = texture2D(tiles, uv);

      return d>0.0 ? vec4(vec3(0.3 + 1.2 * length(clr.rgb), 0.2, 0.1), smoothstep(3.0, 1.5, time-T) * clr.a) : clr;
    }
    
/*
    vec3 cursorColor (vec2 d) {
      if (drawObject == 0) return colors[0];
      if (drawObject == 1) return colors[1];
      if (drawObject == 2) return colors[2];
      if (drawObject == 3) return colors[3];
      if (d.x > 0.0 && d.y < 0.0)
        return colors[0];
      else if (d.x < 0.0 && d.y < 0.0)
        return colors[1];
      else if (d.x > 0.0 && d.y > 0.0)
        return colors[2];
      else
        return colors[3];
    }
    */

    /*
    int cursorElement (vec2 d) {
      if (d.x > 0.0 && d.y < 0.0)
        return 0;
      else if (d.x < 0.0 && d.y < 0.0)
        return 1;
      else if (d.x > 0.0 && d.y > 0.0)
        return 2;
      else
        return 3;
    }
    */

/*
    bool cursorElementHovered (vec2 d, float brushDist) {
      if (!enableCursor) return false;
      float l = length(d);
      if (drawObject != -1) {
        return brushDist < 1.0;
      }
      else {
        float minDist = 4.0;
        float maxDist = 40.0;
        return minDist <= l && l <= maxDist && abs(d.x) > minDist && abs(d.y) > minDist;
      }
    }

    vec4 UI2 (vec3 cin, float brushDist) {
      if (enableCursor) {
        vec2 d = dragStart - gl_FragCoord.xy;
        if (cursorElementHovered(d, brushDist)) {
          float mult = drawObject == -1 ? 1.3 : 1.2;
          return mult * vec4(mix(cin, cursorColor(d), 0.6), 1.0);
        }
      }
      return vec4(0.0);
    }

    vec2 brushDispPass (float brushDist) {
      if (!enableCursor || drawObject == -1) return vec2(0.0);
      float dispBrush = 4.0;
      float dispBrushAmp = 0.1;
      float dispBrushSpeed = 4.0;
      return dispBrush * brushDist * vec2(
        cos(dispBrushSpeed*1.1*time+dispBrushAmp*0.9*gl_FragCoord.x+0.5),
        sin(dispBrushSpeed*time+dispBrushAmp*gl_FragCoord.y+0.1)
      );
    }
    */

    vec2 dispPass (float intensity, float amp, float speed) {
      return intensity * vec2(
        cos(speed*1.1*time+amp*0.9*gl_FragCoord.x+0.5),
        sin(speed*time+amp*gl_FragCoord.y+0.1)
      );
    }

    vec4 stateColorPass (vec4 c, vec2 pos) {
      if (distance(c.rgb, colors[G]) < 0.01) {
        return c * mix(1.0, rand(pos), 0.2);
      }
      return c;
    }


    bool logo (vec2 p, vec2 pos, float size) {
      p = (p - pos) / size;

      return 0.0 < p.y && p.y < 1.0 && (
            
        0.8 < p.x && p.x < 1.0 ||

        1.2 < p.x && p.x < 1.4 ||
        1.2 < p.x && p.x < 2.0 && 0.0 < p.y && p.y < 0.2 ||
        1.2 < p.x && p.x < 2.0 && 0.4 < p.y && p.y < 0.6 ||
        1.2 < p.x && p.x < 1.8 && 0.8 < p.y && p.y < 1.0 ||
        1.6 < p.x && p.x < 1.8 && 0.6 < p.y && p.y < 1.0 ||
        1.8 < p.x && p.x < 2.0 && 0.0 < p.y && p.y < 0.4 ||

        2.2 < p.x && p.x < 2.4 ||
        2.2 < p.x && p.x < 3.0 && 0.0 < p.y && p.y < 0.2 ||
        2.2 < p.x && p.x < 2.8 && 0.4 < p.y && p.y < 0.6 ||
        2.2 < p.x && p.x < 3.0 && 0.8 < p.y && p.y < 1.0 ||

        3.2 < p.x && p.x < 3.4 && !(0.4 < p.y && p.y < 0.6) ||
        3.6 < p.x && p.x < 3.8 && !(0.4 < p.y && p.y < 0.6) ||
        3.4 < p.x && p.x < 3.6 && 0.4 < p.y && p.y < 0.6

      );
    }
    
    void main () {
      /*
      float brushDist = pow(smoothstep(zoom * drawRadius, 0.0, distance(gl_FragCoord.xy, dragStart)), 0.5);
      vec2 disp = brushDispPass(brushDist);
      */
      vec2 disp = vec2(0.0);

      bool lgo = false;
      float s;
      vec2 logoP;
      vec2 grad;

      if (!started || gameover) {
        if (gameover) {
          s = 64.0;
          logoP = vec2((resolution.x - 4.0 * s)/2.0, resolution.y - s * 1.4);
        }
        else {
          s = 140.0;
          logoP = (resolution-vec2(4.0 * s, s))/2.0;
        }
        grad = vec2(3.0*s, 1.6 * s);
        if (logo(gl_FragCoord.xy, logoP, s)) {
          lgo = true;
        }
      }
      if (lgo) {
        disp += dispPass(1.0, 0.1, 2.0);
      }
      

      // Compute where the camera/zoom is in the state texture
      vec2 statePos = (gl_FragCoord.xy + disp + camera) / zoom;
      vec2 statePosFloor = floor(statePos);
      vec2 stateBound = worldSize;
      vec2 uv = (statePosFloor + 0.5) / stateBound;
      bool outOfBound = uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0;
      vec4 stateColor = outOfBound ? vec4(statePos.y < 0.0 ? colors[1] : colors[0], 1.0) : stateColorPass(texture2D(state, uv), statePosFloor);

      vec2 pixelPos = fract(statePos);

      vec3 c = stateColor.rgb;

      vec3 noiseColor = vec3(0.02) * vec3(
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/31.0),
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/80.1),
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/13.2)
      );
      vec3 pixelColor = -vec3(0.03) * (pixelPos.x - pixelPos.y);

      // Bottleneck...

      if (!outOfBound) {
        vec4 animalsColor = vec4(0.0);
        for (int i=0; i<MAX_ANIMALS; ++i) { if (i >= animalsLength) break;
          vec4 c = animal(
              statePos,
              vec2(
              animals[8*i+0],
              animals[8*i+1]),
              vec2(
              animals[8*i+2],
              animals[8*i+3]),
              animals[8*i+4],
              animals[8*i+5],
              animals[8*i+6],
              animals[8*i+7]);

          if (c.a > 0.0) {
            animalsColor = c;
            break;
          }
        }
        vec3 worldColor = c + noiseColor + pixelColor;
        c = animalsColor.a==0.0 ? worldColor : mix(worldColor, animalsColor.rgb, min(1.0, animalsColor.a));
      }
      
      /*
      vec4 ui = UI2(c, distance(statePosFloor, floor((dragStart + camera)/zoom)) / drawRadius);
      c = mix(c.rgb, ui.rgb, ui.a);
      */

      if (!started || gameover) {
        if (lgo) {
          c = 0.3 + 0.8*c;
          if (!started && distance(resolution / 2.0 /  grad, mouse /  grad) < 0.6) {
            c *= 1.4;
          }
        }
        else if (logo(gl_FragCoord.xy, logoP+vec2(8.0, -8.0), s)) {
          c = vec3(0.0);
        }
        else {
          c = mix(c.rgb, vec3(0.0), 0.2 + 0.4 * smoothstep(0.4, 1.0, distance(resolution / 2.0 /  grad, gl_FragCoord.xy /  grad)));
        }
      }

      if (number(score, (gl_FragCoord.xy/resolution.xy) * 128. * vec2(1,resolution.y/resolution.x)) > 0.0) {
        c = 0.2 + 0.8 * (1.0-c);
      }
      
      gl_FragColor = vec4(c, 1.0);
    }
  </script>
  <script src="index.js"></script>
</body>
</html>
