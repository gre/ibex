<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS13K</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <canvas id="C"></canvas>
  <script id="vertexLogic" type="x-shader/x-vertex">
    attribute vec2 position;
    void main() {
      gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);
    }
  </script>
  <script id="fragmentLogic" type="x-shader/x-fragment">
    #define AC(a) if(r==a)c=colors[a];
    #define RAND (seed=vec2(rand(seed), rand(seed+9.))).x

    // Elements
    #define N 0
    #define E 1
    #define F 2
    #define W 3
    #define V 4
    #define S 5
    #define Al 6
    #define Ar 7
    // wildcard
    #define _ 8

    /**
      * Game Rule Interactions.
      *
      * Each interaction use various probability. Some are very rare, some frequent.
      /!\ here air means wind /!\ it is different of empty, the empty space is called "Nothing" aka N)
      *
      * Primary elements: Water, Fire, Earth, Air
      * =======
      * Water + Nothing => fall / slide
      * Fire + Nothing => grow
 TODO     * Air + Nothing => move (directional wind)
 TODO     * Water + Fire => sometimes creates Air (Steam/Wind)
 TODO     * Water + Air => Water is deviated (wind)
 TODO     * Fire + Air => Fire decrease IF not surrounded by air OTHERWISE is increase (need oxygen)
      * Earth + Water => rarely creates Water Source (water infiltration)
      * Earth + Fire => rarely creates Volcano (fire melt ground into lava)
 TODO     * Earth + Air => sometimes Destroy (erosion), rarely creates Fire (spark)
      *
      * Secondary elements: Source, Volcano
      * =========
      * Source + Nothing => creates Water (on bottom).
      * Volcano + Nothing => creates Fire (on top)
 TODO     * Volcano + Source => IF source on top of volcano: sometimes creates Ground. OTHERWISE: sometimes creates volcano.
      * Volcano + Water => rarely creates Source.
      * Earth + Volcano => rarely Volcano expand / grow up in the Earth.
      * Earth + Source => rarely Source expand / infiltrate in the Earth.
      * Source + Fire => Source die.
      *
      * Cases where nothing happens:
      * Earth + Nothing
      * Volcano + Fire
      * Volcano + Air
      * Source + Air
      * Source + Water

      */
  
    precision highp float;
    uniform vec2 size;
    uniform float tick;
    uniform sampler2D state;

    uniform bool draw;
    uniform ivec2 drawPosition;
    uniform float drawRadius;
    uniform int drawObject;

    uniform vec3 colors[_];

    vec4 getColor(ivec2 position) {
      vec2 uv = (gl_FragCoord.xy + vec2(position)*vec2(1.0, -1.0)/* quick fix for the currently reversed Y ...*/) / size;
      if (uv.x < 0.0 || uv.x >= 1.0 || uv.y < 0.0 || uv.y >= 1.0)
        return vec4(colors[0], 0.0);
      return texture2D(state, uv);
    }
    int get (ivec2 pos) {
      vec3 cmp = getColor(pos).rgb;
      for (int i=0; i<_; ++i) {
        vec3 ref = colors[i];
        if (distance(cmp, ref) < 0.01)
          return i;
      }
      return 0;
    }
    int get (int x, int y) {
      return get(ivec2(x, y));
    }


    // Match with weights
    float match (mat3 pattern, mat3 weights, ivec2 off) {
      float w = 0.0;
      for (int x=-1; x<=1; ++x) {
        for (int y=-1; y<=1; ++y) {
          int v = int(pattern[y+1][x+1]);
          if (v == _ || v == get(x+off.x, y+off.y)) {
            w += weights[y+1][x+1];
          }
        }
      }
      return w;
    }

    float match (mat3 pattern, mat3 weights) {
      return match(pattern, weights, ivec2(0));
    }

    // Match a pattern and return the nb of matches (ignoring the wildcards)
    int match (mat3 pattern) {
      mat3 w = mat3(0.0);
      for (int x=0; x<=2; ++x) {
        for (int y=0; y<=2; ++y) {
          if (int(pattern[y][x]) != _)
            w[y][x] = 1.0;
        }
      }
      return int(match(pattern, w));
    }

    bool matchAll (mat3 pattern, ivec2 off) {
      mat3 w = mat3(1.0,1.0,1.0, 1.0,1.0,1.0, 1.0,1.0,1.0);
      return match(pattern, w, off) == 9.0;
    }

    bool matchAll (mat3 pattern) {
      return matchAll(pattern, ivec2(0));
    }

    bool matchAny (mat3 pattern) {
      return match(pattern) > 1;
    }
    bool matchOne (mat3 pattern) {
      return matchAny(pattern);
    }

    bool between (float f, float a, float b) {
      return a <= f && f <= b;
    }

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    void main () {
      
      int prev = get(0, 0);

      vec2 seed = gl_FragCoord.xy + 0.001 * tick;

      int r = N;

      if (draw) {
        vec2 pos = floor(gl_FragCoord.xy);
        if (distance(pos, vec2(drawPosition)) <= drawRadius) {
          r = drawObject;
        }
        else {
          r = prev;
        }
      }
      else {

      //////// FIRE RULES ///////

      if (
       // Fire grow / Fire + Water
       match(mat3(
         W, W, W, // If water drop...
         W, W, W, // ...or water nearby.
         F, F, F  // Fire will move up and expand a bit.
       ), mat3(
         -0.05, -0.3, -0.05, // Negative weights because water kill fire.
         -0.5, -0.6, -0.5,
         0.35, 0.9, 0.35 // Weights for the Fire
       )) >= 0.9 - 0.6 * RAND // The sum of matched weights must be enough important, also with some randomness
      ) {
        r = F;
      }

      ////// WATER RULES ///////

      if (
      // Water drop / Water + Fire
       between(match(mat3(
         W, W, W,
         W, F, W,
         _, F, _
       ), mat3(
         0.3, 0.9, 0.3,
         0.1, -0.6, 0.1,
         0.0, -0.5, 0.0
       )), 0.9 - 0.6 * RAND, 1.4 + 0.3 * RAND)
       ||
       // Water Slide rules
       (
        prev == N && (
          RAND < 0.97 && (
          matchAll(mat3(
            W, _, _,
            _, _, _,
            E, _, _))
          ||
          matchAll(mat3(
            _, _, W,
            _, _, _,
            _, _, E))
          )
          ||
          RAND < 0.92 && (
          matchAll(mat3(
            _, _, _,
            W, _, _,
            E, _, _))
          ||
          matchAll(mat3(
            _, _, _,
            _, _, W,
            _, _, E))
          )))) {
        r = W;
      }

      ////// EARTH RULES ////

      if (prev == E) {
        r = E;

        // Earth -> Source
        if (
        RAND<0.01 &&
        match(mat3(
          W, W, W,
          W, _, W,
          W, W, W
        ), mat3(
         1.0, 1.2, 1.0,
         0.5, 0.0, 0.5,
         0.3, 0.2, 0.3
        ))>3.0 - 2.5*RAND
        ||

        RAND < 0.03 &&
        1<=match(mat3(
          _, S, _,
          S, _, S,
          _, _, _
        ))) {
          r = S;
        }

        // Earth -> Volcano
        if (
        RAND < 0.006 && 
        match(mat3(
          F, F, F,
          F, _, F,
          F, F, F
        ), mat3(
         0.3, 0.2, 0.3,
         0.5, 0.0, 0.5,
         1.0, 1.2, 1.0
        ))>3.0 - 2.1*RAND

        ||

        RAND < 0.01 &&
        2<=match(mat3(
          _, _, _,
          V, _, V,
          V, V, V
        ))) {
          r = V;
        }
      }

      ////// VOLCANO RULES /////
      
      // Volcano creates fire
      if ((prev==N || prev==F) && matchAll(mat3(
          _, _, _,
          _, _, _,
          _, V, _))) {
        r = F;
      }

      if (prev == V) {
        r = V;

        // if Water: Volcano -> Earth
        if (matchAny(mat3(
          W, W, W,
          W, _, W,
          _, _, _
        ))) {
          r = E;
        }

        // cool down: Volcano -> Earth
        if (RAND<0.005 && !matchAny(mat3(
          _, _, _,
          _, _, _,
          F, F, F
        )) && !matchAny(mat3(
          _, _, _,
          _, _, _,
          V, V, V
        ))) {
          r = E;
        }

        // Volcano <-> Source : A volcano can disappear near source
        if (matchAny(mat3(
          S, S, S,
          S, _, S,
          S, S, S
        ))) {
          if (RAND < 0.3) {
            r = V;
          }
          else if (RAND < 0.6) {
            r = S;
          }
          else {
            r = E;
          }
        }
        
      }

      ////// SOURCE RULES /////

      if ((prev==N || prev==W) && match(mat3(
          S, S, S,
          S, _, S,
          _, _, _), mat3(
          0.9, 1.0, 0.9,
          0.7, 0.0, 0.7,
          0.0, 0.0, 0.0
        )) >= 1.0 - 0.3*RAND) {
        r = W;
      }

      if (prev == S) {
        r = S;

        // Dry: Source -> Earth
        if (RAND<0.06 && !matchAny(mat3(
          W, W, W,
          _, _, _,
          _, _, _
        )) && !matchAny(mat3(
          S, S, S,
          _, _, _,
          _, _, _
        ))) {
          r = E;
        }

        // if Fire: Source -> Earth
        if (matchAny(mat3(
          _, _, _,
          F, _, F,
          F, F, F
        ))) {
          r = E;
        }

        // Volcano <-> Source : A source can disappear near volcano
        if (matchAny(mat3(
          V, V, V,
          V, _, V,
          V, V, V
        ))) {
          if (RAND < 0.2) {
            r = V;
          }
          else if (RAND < 0.6) {
            r = S;
          }
          else {
            r = E;
          }
        }
      }

      ////// AIR RULES //////
      if (r == N) {
        if (RAND < 0.00001) r = Al;
        if (RAND < 0.00001) r = Ar;
      }
      bool aR = matchAll(mat3(
        _, _, _,
        Ar,_, _,
        _, _, _
      ));
      bool aL = matchAll(mat3(
        _, _, _,
        _ ,_,Al,
        _, _, _
      ));
      int airRes = aR && !aL ? Ar : aL && !aR ? Al : N;

      if (aR || aL) {
        if (prev==N) {
          r = airRes;
        }
        if (r==F) {
          r = RAND < 0.9 ? airRes : N;
        }
        if (r==W) {
          r = RAND < 0.9 ? airRes : N;
        }
      }

      if (prev == N || prev == Al || prev == Ar || prev == F || prev == W) {
        if (matchAll(mat3(
          W, _, _,
          _, _, _,
          F, _, _
        ))) {
          r = Ar;
        }
        if (matchAll(mat3(
          _, _, W,
          _, _, _,
          _, _, F
        ))) {
          r = Al;
        }
      }


      }
      ///// Return the color result /////

      vec3 c;AC(0)AC(1)AC(2)AC(3)AC(4)AC(5)AC(6)AC(7)gl_FragColor=vec4(c,1.0); //: gl_FragColor=vec4(colors[r], 1.0);
    }
  </script>
  
  <script id="vertexRender" type="x-shader/x-vertex">
    attribute vec2 position; void main() { gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);}
  </script>
  <script id="fragmentRender" type="x-shader/x-fragment">
    #define AC(a) if(r==a)c=colors[a];
    #define RtoC AC(0)AC(1)AC(2)AC(3)AC(4)AC(5)AC(6)AC(7)

    #define OUTCOLOR vec4(0.0)
    #define MAX_ANIMALS 20
    #define UI_SIZE 50.
    #define UI_LENGTH 4

    #define N 0
    #define E 1
    #define F 2
    #define W 3
    #define V 4
    #define S 5
    #define Al 6
    #define Ar 7
    #define _ 8
  
    precision highp float;

    uniform vec3 colors[_];

    uniform int uiElements[UI_LENGTH];

    uniform vec2 worldSize;
    uniform vec2 resolution;

    uniform float zoom;
    uniform vec2 camera;
    uniform vec2 mouse;

    uniform float time;
    uniform sampler2D state;
    uniform vec2 animals[MAX_ANIMALS];
    uniform int animalsLength;

    uniform bool draggingElement;
    uniform float drawRadius;
    uniform int drawObject;

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    vec4 animal (vec2 p, vec2 pos, bool reversed) {
      int x = int(p.x - pos.x), y = int(p.y - pos.y);
      if (reversed) x = -x;
      if (
        ((x == -3 || x == -1) && (y == 4 || y == 5)) ||
        (x == -2 && (0 <= y && y <= 3)) ||
        (x == 1 && (0 <= y && y <= 2)) ||
        ((-1 <= x && x <= 1) && y == 2)
      )
        return vec4(0.6, 0.4, 0.2, 1.0);
      return vec4(0.0);
    }

    vec4 UI () {
      vec2 p = gl_FragCoord.xy / UI_SIZE;
      if (p.y <= 1.0 && p.y <= UI_SIZE * float(UI_LENGTH)) {
        int x = int(p.x);
        float dist = distance(gl_FragCoord.xy, (0.5+floor(p)) * UI_SIZE );
        if (dist < UI_SIZE/2.0 - 4.0) {
          for (int i=0; i<UI_LENGTH; ++i) {
            if (x == i) {
              int r = uiElements[i];
              vec3 c; RtoC
              return vec4(c, 1.0);
            }
          }
        }
      }
      if (gl_FragCoord.y < UI_SIZE + 4.0) {
        return vec4(0.0, 0.0, 0.0, 0.6);
      }
      return vec4(0.0);
    }

    vec3 brushColorPass (vec3 cin, float dist) {
      if (!draggingElement || dist > 1.0) return cin;
      int r = drawObject;
      vec3 c; RtoC
      return cin + c - vec3(0.3);
    }

    vec2 brushDispPass (float brushDist) {
      if (!draggingElement) return vec2(0.0);
      float dispBrush = 4.0;
      float dispBrushAmp = 0.1;
      float dispBrushSpeed = 4.0;
      return dispBrush * brushDist * vec2(
        cos(dispBrushSpeed*1.1*time+dispBrushAmp*0.9*gl_FragCoord.x+0.5),
        sin(dispBrushSpeed*time+dispBrushAmp*gl_FragCoord.y+0.1)
      );
    }
    
    void main () {
      float brushSize = 8.0;
      float brushDist = pow(smoothstep(zoom * brushSize, 0.0, distance(gl_FragCoord.xy, mouse)), 0.5);
      vec2 disp = brushDispPass(brushDist);

      // Compute where the camera/zoom is in the state texture
      vec2 statePos = (gl_FragCoord.xy + disp + camera) / zoom;
      vec2 statePosFloor = floor(statePos);
      vec2 stateBound = worldSize;
      vec2 uv = (statePosFloor + 0.5) / stateBound;
      vec4 stateColor = uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0 ? OUTCOLOR : texture2D(state, uv);

      vec2 pixelPos = fract(statePos);

      vec3 noiseColor = /* DISABLED for now */0.0 * vec3(0.02) * vec3(
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/31.0),
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/80.1),
        rand(zoom*floor(gl_FragCoord.xy/zoom)+time/13.2)
      );

      vec3 pixelColor = -vec3(0.03) * (pixelPos.x - pixelPos.y);

      vec4 worldColor = vec4(noiseColor + pixelColor, 1.0) + stateColor;

      vec4 animalsColor = vec4(0.0);

      for (int i=0; i<MAX_ANIMALS; ++i) { if (i >= animalsLength) break;
        vec4 c = animal(statePosFloor, animals[i], mod(time + float(i)/9.0, 1.0) < 0.5);
        if (c.a > 0.0)
          animalsColor = c;
      }
      
      vec3 c = mix(worldColor, animalsColor, min(1.0, animalsColor.a)).rgb;
      c = brushColorPass(c, distance(statePosFloor, floor((mouse + camera)/zoom)) / brushSize);
      vec4 ui = UI();
      c = mix(c.rgb, ui.rgb, ui.a);
      gl_FragColor = vec4(c, 1.0);
    }
  </script>
  <script src="seedrandom.min.js"></script>
  <script src="index.js"></script>
</body>
</html>
