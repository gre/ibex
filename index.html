<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS13K</title>
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <canvas id="C"></canvas>
  <script id="vertexLogic" type="x-shader/x-vertex">
    attribute vec2 position;
    void main() {
      gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);
    }
  </script>
  <script id="fragmentLogic" type="x-shader/x-fragment">
    #define AC(a) if(r==a)c=colors[a];

    // Elements
    #define N 0
    #define E 1
    #define F 2
    #define W 3
    #define V 4
    #define S 5
    #define A 6
    // wildcard
    #define _ 7

    /**
      * Game Rule Interactions.
      *
      * Each interaction use various probability. Some are very rare, some frequent.
      /!\ here air means wind /!\ it is different of empty, the empty space is called "Nothing" aka N)
      *
      * Primary elements: Water, Fire, Earth, Air
      * =======
      * Water + Nothing => fall / slide
      * Fire + Nothing => grow
      * Air + Nothing => move (directional wind)
      * Water + Fire => sometimes creates Air (Steam/Wind)
      * Water + Air => Water is deviated (wind)
      * Fire + Air => Fire decrease IF not surrounded by air OTHERWISE is increase (need oxygen)
      * Earth + Water => rarely creates Water Source (water infiltration)
      * Earth + Fire => rarely creates Volcano (fire melt ground into lava)
      * Earth + Air => sometimes Destroy (erosion), rarely creates Volcano (spark)
      *
      * Secondary elements: Source, Volcano
      * =========
      * Source + Nothing => creates Water (on bottom).
      * Volcano + Nothing => creates Fire (on top)
      * Volcano + Source => IF source on top of volcano: sometimes creates Ground. OTHERWISE: sometimes creates volcano.
      * Volcano + Water => rarely creates Source.
      * Earth + Volcano => rarely Volcano expand / grow up in the Earth.
      * Earth + Source => rarely Source expand / infiltrate in the Earth.
      * Source + Fire => Source die.
      *
      * Cases where nothing happens:
      * Earth + Nothing
      * Volcano + Fire
      * Volcano + Air
      * Source + Air
      * Source + Water
      */
  
    precision highp float;
    uniform vec2 size;
    uniform float time;
    uniform sampler2D state;

    uniform vec3 colors[_];

    vec4 getColor(ivec2 position) {
      return texture2D(state, mod((gl_FragCoord.xy + vec2(position)*vec2(1.0, -1.0)/* quick fix for the currently reversed Y ...*/) / size, vec2(1.0)));
    }
    int get (ivec2 position) {
      vec3 cmp = getColor(position).rgb;
      for (int i=0; i<_; ++i) {
        vec3 ref = colors[i];
        if (distance(cmp, ref) < 0.01)
          return i;
      }
      return 0;
    }
    int get (int x, int y) {
      return get(ivec2(x, y));
    }


    // Match with weights
    float match (mat3 pattern, mat3 weights) {
      float w = 0.0;
      for (int x=-1; x<=1; ++x) {
        for (int y=-1; y<=1; ++y) {
          int v = int(pattern[y+1][x+1]);
          if (v == _ || v == get(x, y)) {
            w += weights[y+1][x+1];
          }
        }
      }
      return w;
    }

    // Match a pattern and return the nb of matches (ignoring the wildcards)
    int match (mat3 pattern) {
      mat3 w = mat3(0.0);
      for (int x=0; x<=2; ++x) {
        for (int y=0; y<=2; ++y) {
          if (int(pattern[y][x]) != _)
            w[y][x] = 1.0;
        }
      }
      return int(match(pattern, w));
    }

    bool matchAll (mat3 pattern) {
      mat3 w = mat3(1.0,1.0,1.0, 1.0,1.0,1.0, 1.0,1.0,1.0);
      return match(pattern, w) == 9.0;
    }

    bool matchAny (mat3 pattern) {
      return match(pattern) > 1;
    }

    bool between (float f, float a, float b) {
      return a <= f && f <= b;
    }

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }

    void main () {
      float o = rand(gl_FragCoord.xy + 0.00001*time * 0.1);
      float oo = rand(gl_FragCoord.xy + 0.00001*time * 9.1 + 13.91);
      
      int prev = get(0, 0);

      int r = N;

      //////// FIRE RULES ///////

      if (1==match(mat3(
          _, _, _,
          _, _, _,
          _, V, _))) {
        r = F;
      }
      else 
      if (
       // Fire rule with Water interaction
       match(mat3(
         W, W, W, // If water drop...
         W, W, W, // ...or water nearby.
         F, F, F  // Fire will move up and expand a bit.
       ), mat3(
         -0.05, -0.3, -0.05, // Negative weights because water kill fire.
         -0.5, -0.6, -0.5,
         0.35, 0.9, 0.35 // Weights for the Fire
       )) >= 0.9 - 0.6 * oo // The sum of matched weights must be enough important, also with some randomness
      ) {
        r = F;
      }

      ////// WATER RULES ///////

      if (1==match(mat3(
          _, S, _,
          _, _, _,
          _, _, _))) {
        r = W;
      }
      else if (
        prev == N &&
        oo < 0.95 && (
        matchAll(mat3(
          W, _, _,
          _, _, _,
          E, _, _))
        ||
        matchAll(mat3(
          _, _, W,
          _, _, _,
          _, _, E))
        )
        ||
        oo < 0.88 && (
        matchAll(mat3(
          _, _, _,
          W, _, _,
          E, _, _))
        ||
        matchAll(mat3(
          _, _, _,
          _, _, W,
          _, _, E))
        )) {
        r = W;
      }
      else if (between(match(mat3(
         W, W, W,
         W, F, W,
         _, F, _
       ), mat3(
         0.3, 0.9, 0.3,
         0.1, -0.3, 0.1,
         0.0, -0.3, 0.0
       )), 0.99 - 0.61 * o, 1.5 + 0.5 * oo)) {
        r = W;
      }

      ////// EARTH RULES ////

      if (prev == E) {
        if (oo>0.96 && (
        match(mat3(
          F, F, F,
          F, _, F,
          F, F, F
        ), mat3(
         0.3, 0.2, 0.3,
         0.5, 0.0, 0.5,
         1.0, 1.2, 1.0
        ))>3.0 - 2.1*o
        ||
        2==match(mat3(
          _, _, _,
          V, _, V,
          V, V, V
        )))) {
          r = V;
        }
        else {
          r = E;
        }
      }

      ////// VOLCANO RULES /////

      if (prev == V) {
        if (matchAny(mat3(
          _, W, _,
          W, _, W,
          _, _, _
        ))) {
          r = E;
        }
        else {
          r = V;
        }
      }

      ////// SOURCE RULES /////

      if (prev == S) {
        if (matchAny(mat3(
          _, _, _,
          F, _, F,
          _, F, _
        ))) {
          r = E;
        }
        else {
          r = S;
        }
      }

      ///// Return the color result /////

      vec3 c;AC(0)AC(1)AC(2)AC(3)AC(4)AC(5)AC(6)gl_FragColor=vec4(c,1.0); //: gl_FragColor=vec4(colors[r], 1.0);
    }
  </script>
  
  <script id="vertexRender" type="x-shader/x-vertex">
    attribute vec2 position; void main() { gl_Position = vec4(2.0*position-1.0, 0.0, 1.0);}
  </script>
  <script id="fragmentRender" type="x-shader/x-fragment">
    precision highp float;
    uniform vec2 size;
    uniform vec2 resolution;
    uniform float time;
    uniform sampler2D logic;

    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }
    
    void main () {
      vec2 ratio = vec2(1.0);//resolution / size;
      vec2 p = ratio * floor(gl_FragCoord.xy / ratio + 0.5) / resolution;
      gl_FragColor = -(0.05*rand(p+time/1000.0)) + texture2D(logic, p /*+ 0.002*vec2(
        cos(2.3*time+07.0*p.x+0.5*rand(p+time/100.0)),
        sin(2.0*time+15.0*p.y+0.1*rand(p+time/1000.0)
      ))*/);
    }
  </script>
  <script src="index.js"></script>
</body>
</html>
